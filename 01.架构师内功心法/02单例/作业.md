# 第一部分 熟练掌握单例模式的常见写法。
## 1. 饿汉式
``` 
//非静态块饿汉式单例
public class HungrySingleton {
    private static final HungrySingleton hungrySingleton = new HungrySingleton();
    private HungrySingleton(){}
    public static HungrySingleton getInstance(){
        return  hungrySingleton;
    }
}

//静态块饿汉式单例
public class HungryStaticSingleton {
    private static final HungryStaticSingleton hungrySingleton;
    static {
        hungrySingleton = new HungryStaticSingleton();
    }
    private HungryStaticSingleton(){}
    public static HungryStaticSingleton getInstance(){
        return  hungrySingleton;
    }
}
``` 
## 2.懒汉式
```
//加锁简单懒汉式单例
public class LazySimpleSingleton {
    private LazySimpleSingleton(){}
    //静态块，公共内存区域
    private static LazySimpleSingleton lazy = null;
    public synchronized static LazySimpleSingleton getInstance(){
        if(lazy == null){
            lazy = new LazySimpleSingleton();
        }
        return lazy;
    }
    public static  void running(){
        System.out.println("跑步123321");
    }
}

//双重检查锁懒汉单例
public class LazyDoubleCheckSingleton {
    private volatile static LazyDoubleCheckSingleton lazy = null;

    private LazyDoubleCheckSingleton(){}
    public static LazyDoubleCheckSingleton getInstance(){
        if(lazy == null){
            synchronized (LazyDoubleCheckSingleton.class){
                if(lazy == null){
                    lazy = new LazyDoubleCheckSingleton();
                }
            }
        }
        return lazy;
    }
}

//内部类懒汉式单例
//这种形式兼顾饿汉式的内存浪费，也兼顾synchronized性能问题
public class LazyInnerClassSingleton {
    //默认使用LazyInnerClassGeneral的时候，会先初始化内部类
    //如果没使用的话，内部类是不加载的
    private LazyInnerClassSingleton(){
        System.out.println("LazyInnerClassSingleton初始化时"+LazyHolder.LAZY);
        if(LazyHolder.LAZY != null){
            throw new RuntimeException("不允许创建多个实例");
        }
    }

    //static 是为了使单例的空间共享
    //保证这个方法不会被重写，重载
    public static final LazyInnerClassSingleton getInstance(){
        //在返回结果以前，一定会先加载内部类
        return LazyHolder.LAZY;
    }

    //默认不加载
    private static class LazyHolder{
        private static final LazyInnerClassSingleton LAZY = new LazyInnerClassSingleton();
        static{
            System.out.println("懒加载"+LAZY);
        }
    }
}
```
## 3.注册式单例(使用Map存储,枚举等数据结构存储)
```
//枚举注册式单例
public enum EnumSingleton {
    INSTANCE;
    private Object data;
    public Object getData() {
        return data;
    }
    public void setData(Object data) {
        this.data = data;
    }
    public static EnumSingleton getInstance(){
        return INSTANCE;
    }
}

//容器缓存式注册式单例1
//Spring中的做法，就是用这种注册式单例
public class ContainerSingleton {
    private ContainerSingleton(){}
    private static Map<String,Object> ioc = new ConcurrentHashMap<String,Object>();
    public static Object getInstance(String className){
        synchronized (ioc) {
            if (!ioc.containsKey(className)) {
                Object obj = null;
                try {
                    obj = Class.forName(className).newInstance();
                    ioc.put(className, obj);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                return obj;
            } else {
                return ioc.get(className);
            }
        }
    }
}

//容器缓存式注册式单例 ThreadLocal
public class ThreadLocalSingleton {
    private static final ThreadLocal<ThreadLocalSingleton> threadLocalInstance =
            new ThreadLocal<ThreadLocalSingleton>(){
                @Override
                protected ThreadLocalSingleton initialValue() {
                    return new ThreadLocalSingleton();
                }
            };

    private ThreadLocalSingleton(){}

    public static ThreadLocalSingleton getInstance(){
        return threadLocalInstance.get();
    }
}
```
# 第二部分 总结每种单例写法的优、缺点。
## 1. 饿汉式
> 它是在类加载的时候就立即初始化，并且创建单例对象

 优点：1.没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好 2.绝对线程安全，在线程还没出现以前就是实例化了，不可能存在访问安全问题
 
 缺点：类加载的时候就初始化，有可能占着茅坑不拉屎，浪费了内存。有可能被反射/序列化破坏。

## 2.懒汉式

> 加锁饿汉式

优点：比起饿汉式不使用时不占内存

缺点：使用时才初始化，使用锁机制，性能验没饿汉式好，有可能被反射/序列化破坏。

> 静态内部类饿汉式 ---推荐使用

优点：兼顾内存和性能

## 3.注册式
> 枚举注册式 ---推荐使用

 优点1.枚举可解决线程安全问题

（1)枚举中的各个枚举项通过static来定义的

（2）static类型的属性会在类被加载之后被初始化

（3）当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的（因为虚拟机在加载枚举的类的时候，会使用ClassLoader的loadClass方法，而这个方法使用同步代码块保证了线程安全）。所以，创建一个enum类型是线程安全的。

 优点2、枚举可解决反序列化会破坏单例的问题

（1）普通的Java类的反序列化过程中，会通过反射调用类的默认构造函数来初始化对象

（2）在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。

> 容器注册式

 优点：
 
 缺点：线程不安全，ThreadLocal也只能保证单个线程唯一
 
# 第三部分 思考破坏单例模式的方式有哪些？并且归纳总结。

1.反射破坏单例

通过反射获取构造函数，新建对象

2.序列化单例

将一个对象序列化到磁盘后反序列化成新对象，新旧两对象是不一样的

反制方法：增加readResolve() 方法返回实例 

原理：反射创建对象后会调用readResolve()方法，判断其是否有值来返回对象，注意对象还是创建但没返回而已，是JDK留下来反制反射破坏单例的方式

# 第四部分 梳理内部类的执行逻辑，并画出时序图。
参考博客：[https://blog.csdn.net/u013435893/article/details/79579344]()
先看博客：
调用权限及原因

|                     | 被外部类访问部分                      | 访问外部类部分    |
| --------            | -----:                             | :----:            |
| 静态内部类           |  外部类的静态变量和方法     |                        | 
| 静态内部类原理       |  静态变量和方法先初始化             |                  |
| 成员内部类     |     |      |
| 成员内部类原因     |   |       |
| 成员内部类     |    |      |
| 成员内部类原因     |   |      |
| 方法内部类     |     |      |
| 方法内部类原因     |   |     |
| 匿名内部类     |     |      |
| 匿名内部类原因     |   |       |







